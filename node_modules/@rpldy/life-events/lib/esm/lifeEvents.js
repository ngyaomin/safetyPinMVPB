function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import isPromise from "is-promise";
import defaults from "./defaults";
import { validateFunction, isUndefined } from "./utils";
import { LESYM, LE_PACK_SYM } from "./consts";

//TODO: implement STATS
var getLE = function (obj) {
  return obj ? obj[LESYM] : null;
};

var getValidLE = function (obj) {
  var le = getLE(obj);

  if (!le) {
    throw new Error("Didnt find LE internal object. Something very bad happened!");
  }

  return le;
};

var isLE = function (obj) {
  return !!getLE(obj);
};

var addRegistration = function (obj, name, cb) {
  var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  validateFunction(cb, "cb");
  var le = getValidLE(obj);

  if (!le.options.allowRegisterNonExistent && !~le.events.indexOf(name)) {
    throw new Error("Cannot register for event ".concat(name.toString(), " that wasn't already defined (allowRegisterNonExistent = false)"));
  }

  var namedRegistry = le.registry[name] || [];

  if (!namedRegistry.find(function (r) {
    return r.cb === cb;
  })) {
    //only add same callback for a name once
    namedRegistry.push({
      name: name,
      cb: cb,
      once: once
    });
    le.registry[name] = namedRegistry;
  }

  return function () {
    return unregister.call(obj, name, cb);
  };
};

var findRegistrations = function (obj, name) {
  var registry = getValidLE(obj).registry;
  return name ? registry[name] ? registry[name].slice() : [] : // $FlowFixMe - flow doesnt know about Array.prototype.flat yet...
  Object.values(registry).flat();
};

var publicMethods = {
  "on": register,
  "once": registerOnce,
  "off": unregister,
  "getEvents": getEvents
};

var getPublicMethods = function () {
  return Object.entries(publicMethods).reduce(function (res, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        m = _ref2[1];

    res[key] = {
      value: m
    };
    return res;
  }, {});
}; //using string keys here because can't rely on function names to stay after (babel/webpack) build


var apiMethods = {
  "trigger": trigger,
  "addEvent": addEvent,
  "removeEvent": removeEvent,
  "hasEvent": hasEvent,
  "hasEventRegistrations": hasEventRegistrations,
  "assign": assign
};

var createApi = function (target) {
  return Object.keys(apiMethods).reduce(function (res, name) {
    res[name] = apiMethods[name].bind(target);
    return res;
  }, _objectSpread({
    target: target
  }, apiMethods));
};

var cleanRegistryForName = function (obj, name) {
  var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var registry = getValidLE(obj).registry;

  if (registry[name] && (force || !registry[name].length)) {
    delete registry[name];
  }
};

var removeRegItem = function (obj, name, cb) {
  var registry = getValidLE(obj).registry;

  if (registry[name]) {
    if (!cb) {
      cleanRegistryForName(obj, name, true);
    } else {
      registry[name] = registry[name].filter(function (reg) {
        return reg.cb !== cb;
      });
      cleanRegistryForName(obj, name);
    }
  }
};

function register(name, cb) {
  return addRegistration(this, name, cb);
}

function registerOnce(name, cb) {
  return addRegistration(this, name, cb, true);
}

function unregister(name, cb) {
  removeRegItem(this, name, cb);
}

function getEvents() {
  return getValidLE(this).events.slice();
}

function trigger(name) {
  var _this = this;

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var regs = findRegistrations(this, name);
  var results;

  if (regs.length) {
    var _args$;

    var packValue;

    if (args.length === 1 && ((_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$[LE_PACK_SYM]) === true) {
      //life-pack always returns array as params to spread
      packValue = args[0].resolve();
    }

    results = regs.map(function (r) {
      var result;

      if (r.once) {
        removeRegItem(_this, name, r.cb);
      }

      if (packValue) {
        result = r.cb.apply(r, _toConsumableArray(packValue));
      } else if (!args.length) {
        result = r.cb();
      } else if (args.length === 1) {
        result = r.cb(args[0]);
      } else if (args.length === 2) {
        result = r.cb(args[0], args[1]);
      } else if (args.length === 3) {
        result = r.cb(args[0], args[1], args[2]);
      } else {
        result = r.cb.apply(r, args);
      }

      return result;
    }).filter(function (result) {
      return !isUndefined(result);
    }).map(function (result) {
      return isPromise(result) ? result : Promise.resolve(result);
    });
  }

  return results && (results.length ? results : undefined);
} //registry, events, stats become shared


function assign(toObj) {
  var le = getValidLE(this);
  defineLifeData(toObj, le.options, le.events, le.registry, le.stats);
  return createApi(toObj);
}

function addEvent(name) {
  var le = getValidLE(this);

  if (le.options.canAddEvents) {
    var index = le.events.indexOf(name);

    if (!~index) {
      le.events.push(name);
    } else {
      throw new Error("Event '".concat(name, "' already defined"));
    }
  } else {
    throw new Error("Cannot add new events (canAddEvents = false)");
  }
}

function removeEvent(name) {
  var le = getValidLE(this);

  if (le.options.canRemoveEvents) {
    var index = le.events.indexOf(name);
    le.events.splice(index, 1);
  } else {
    throw new Error("Cannot remove events (canRemoveEvents = false)");
  }
}

function hasEvent(name) {
  var le = getValidLE(this);
  return !!~le.events.indexOf(name);
}

function hasEventRegistrations(name) {
  return !!findRegistrations(this, name).length;
} // function getStats(name?: any) {
//
// }


var defineLifeData = function (target, options) {
  var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var registry = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var stats = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  Object.defineProperties(target, _objectSpread(_defineProperty({}, LESYM, {
    value: Object.seal({
      registry: registry,
      events: events,
      options: options,
      stats: stats
    })
  }), getPublicMethods()));
};

var addLife = function (target) {
  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var options = arguments.length > 2 ? arguments[2] : undefined;
  target = target || {};
  options = _objectSpread(_objectSpread({}, defaults), options);

  if (!isLE(target)) {
    defineLifeData(target, options, events);
  }

  return createApi(target);
};

export default addLife;
export { isLE };