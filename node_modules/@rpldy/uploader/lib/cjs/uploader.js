"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _lifeEvents = _interopRequireWildcard(require("@rpldy/life-events"));

var _shared = require("@rpldy/shared");

var _processor = _interopRequireDefault(require("./processor"));

var _consts = require("./consts");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var EVENT_NAMES = Object.values(_consts.UPLOADER_EVENTS);
var EXT_OUTSIDE_ENHANCER_TIME = "Uploady - uploader extensions can only be registered by enhancers",
    EXT_ALREADY_EXISTS = "Uploady - uploader extension by this name [%s] already exists";
var counter = 0;

var _default = function _default(options) {
  counter += 1;
  var uploaderId = "uploader-".concat(counter);
  var enhancerTime = false;
  var pendingBatches = [],
      extensions = {};

  _shared.logger.debugLog("uploady.uploader: creating new instance (".concat(uploaderId, ")"), {
    options: options,
    counter: counter
  });

  var uploaderOptions = (0, _utils.getMandatoryOptions)(options);

  var update = function (updateOptions) {
    //TODO: updating concurrent and maxConcurrent means we need to update the processor - not supported yet!
    uploaderOptions = (0, _shared.merge)({}, uploaderOptions, updateOptions); //need deep merge for destination

    return uploader;
  };

  var add = function (files, addOptions) {
    var processOptions = (0, _shared.merge)({}, uploaderOptions, addOptions);
    var batch = processor.addNewBatch(files, uploader.id, processOptions);
    var resultP;

    if (batch.items.length) {
      resultP = processor.runCancellable(_consts.UPLOADER_EVENTS.BATCH_ADD, batch, processOptions).then(function (isCancelled) {
        if (!isCancelled) {
          _shared.logger.debugLog("uploady.uploader [".concat(uploader.id, "]: new items added - auto upload =\n                        ").concat(String(processOptions.autoUpload)), batch.items);

          if (processOptions.autoUpload) {
            processor.process(batch);
          } else {
            if (processOptions.clearPendingOnAdd) {
              clearPending();
            }

            pendingBatches.push({
              batch: batch,
              uploadOptions: processOptions
            });
          }
        } else {
          batch.state = _shared.BATCH_STATES.CANCELLED;
          triggerWithUnwrap(_consts.UPLOADER_EVENTS.BATCH_CANCEL, batch);
        }
      });
    } else {
      _shared.logger.debugLog("uploady.uploader: no items to add. batch ".concat(batch.id, " is empty. check fileFilter if this isn't intended"));
    }

    return resultP || Promise.resolve();
  };

  var clearPending = function () {
    pendingBatches.splice(0);
  };
  /**
   * Tells the uploader to process batches that weren't auto-uploaded
   */


  var getOptions = function () {
    return (0, _shared.clone)(uploaderOptions);
  };

  var registerExtension = function (name, methods) {
    (0, _shared.invariant)(enhancerTime, EXT_OUTSIDE_ENHANCER_TIME);
    (0, _shared.invariant)(!extensions[name], EXT_ALREADY_EXISTS, name);

    _shared.logger.debugLog("uploady.uploader: registering extension: ".concat(name.toString()), methods);

    extensions[name] = methods;
  };

  var _addLife = (0, _lifeEvents["default"])({
    id: uploaderId,
    update: update,
    add: add,
    upload: function upload(uploadOptions) {
      pendingBatches.splice(0).forEach(function (_ref) {
        var batch = _ref.batch,
            batchOptions = _ref.uploadOptions;
        return processor.process(batch, (0, _shared.merge)({}, batchOptions, uploadOptions));
      });
    },
    abort: function abort(id) {
      processor.abort(id);
    },
    abortBatch: function abortBatch(id) {
      processor.abortBatch(id);
    },
    getOptions: getOptions,
    getPending: function getPending() {
      return pendingBatches.slice();
    },
    clearPending: clearPending,
    registerExtension: registerExtension,
    getExtension: function getExtension(name) {
      return extensions[name];
    }
  }, EVENT_NAMES, {
    canAddEvents: false,
    canRemoveEvents: false
  }),
      trigger = _addLife.trigger,
      uploader = _addLife.target;
  /**
   * ensures that data being exposed to client-land isnt a proxy, only pojos
   */


  var triggerWithUnwrap = function (name) {
    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    //delays unwrap to the very last time on trigger. Will only unwrap if there are listeners
    var lp = (0, _lifeEvents.createLifePack)(function () {
      return data.map(_utils.deepProxyUnwrap);
    });
    return trigger(name, lp);
  };

  var cancellable = (0, _shared.triggerCancellable)(triggerWithUnwrap);

  if (uploaderOptions.enhancer) {
    enhancerTime = true;
    var enhanced = uploaderOptions.enhancer(uploader, triggerWithUnwrap);
    enhancerTime = false; //graceful handling for enhancer forgetting to return uploader

    uploader = enhanced || uploader;
  }

  var processor = (0, _processor["default"])(triggerWithUnwrap, cancellable, uploaderOptions, uploader.id);
  return (0, _shared.devFreeze)(uploader);
};

exports["default"] = _default;