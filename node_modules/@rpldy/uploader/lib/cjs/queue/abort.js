"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.abortBatch = exports.abortItem = exports.abortAll = void 0;

var _shared = require("@rpldy/shared");

var _consts = require("../consts");

var _batchHelpers = require("./batchHelpers");

var _processFinishedRequest = _interopRequireDefault(require("./processFinishedRequest"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var isItemInProgress = function (state) {
  return state === _shared.FILE_STATES.ADDED || state === _shared.FILE_STATES.UPLOADING;
};

var callAbortOnItem = function (queue, id, next) {
  var abortCalled = false;
  var state = queue.getState(),
      item = state.items[id];

  if (item && isItemInProgress(item.state)) {
    _shared.logger.debugLog("uploader.queue: aborting item in progress - ", item);

    if (item.state === _shared.FILE_STATES.UPLOADING) {
      queue.updateState(function (state) {
        state.items[id].state = _shared.FILE_STATES.ABORTED;
      });
      abortCalled = state.aborts[id]();
    } else {
      //manually finish request for added item that hasnt reached the sender yet
      (0, _processFinishedRequest["default"])(queue, [{
        id: id,
        info: {
          status: 0,
          state: _shared.FILE_STATES.ABORTED,
          response: "aborted"
        }
      }], next);
      abortCalled = true;
    }
  }

  return abortCalled;
};

var abortAll = function (queue, next) {
  var items = queue.getState().items;
  Object.keys(items).forEach(function (id) {
    return callAbortOnItem(queue, id, next);
  });
  queue.trigger(_consts.UPLOADER_EVENTS.ALL_ABORT);
};

exports.abortAll = abortAll;

var abortItem = function (queue, id, next) {
  return callAbortOnItem(queue, id, next);
};

exports.abortItem = abortItem;

var abortBatch = function (queue, id, next) {
  var state = queue.getState(),
      batchData = state.batches[id],
      batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;

  if (batch && batch.state !== _shared.BATCH_STATES.CANCELLED && batch.state !== _shared.BATCH_STATES.FINISHED) {
    batch.items.forEach(function (bi) {
      return callAbortOnItem(queue, bi.id, next);
    });
    queue.updateState(function (state) {
      (0, _batchHelpers.getBatchFromState)(state, id).state = _shared.BATCH_STATES.ABORTED;
    });
    (0, _batchHelpers.triggerUploaderBatchEvent)(queue, id, _consts.UPLOADER_EVENTS.BATCH_ABORT);
  }
};

exports.abortBatch = abortBatch;