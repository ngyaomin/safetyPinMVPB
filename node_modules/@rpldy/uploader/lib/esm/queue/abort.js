import { BATCH_STATES, FILE_STATES, logger } from "@rpldy/shared";
import { UPLOADER_EVENTS } from "../consts";
import { triggerUploaderBatchEvent, getBatchFromState } from "./batchHelpers";
import processFinishedRequest from "./processFinishedRequest";

var isItemInProgress = function (state) {
  return state === FILE_STATES.ADDED || state === FILE_STATES.UPLOADING;
};

var callAbortOnItem = function (queue, id, next) {
  var abortCalled = false;
  var state = queue.getState(),
      item = state.items[id];

  if (item && isItemInProgress(item.state)) {
    logger.debugLog("uploader.queue: aborting item in progress - ", item);

    if (item.state === FILE_STATES.UPLOADING) {
      queue.updateState(function (state) {
        state.items[id].state = FILE_STATES.ABORTED;
      });
      abortCalled = state.aborts[id]();
    } else {
      //manually finish request for added item that hasnt reached the sender yet
      processFinishedRequest(queue, [{
        id: id,
        info: {
          status: 0,
          state: FILE_STATES.ABORTED,
          response: "aborted"
        }
      }], next);
      abortCalled = true;
    }
  }

  return abortCalled;
};

var abortAll = function (queue, next) {
  var items = queue.getState().items;
  Object.keys(items).forEach(function (id) {
    return callAbortOnItem(queue, id, next);
  });
  queue.trigger(UPLOADER_EVENTS.ALL_ABORT);
};

var abortItem = function (queue, id, next) {
  return callAbortOnItem(queue, id, next);
};

var abortBatch = function (queue, id, next) {
  var state = queue.getState(),
      batchData = state.batches[id],
      batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;

  if (batch && batch.state !== BATCH_STATES.CANCELLED && batch.state !== BATCH_STATES.FINISHED) {
    batch.items.forEach(function (bi) {
      return callAbortOnItem(queue, bi.id, next);
    });
    queue.updateState(function (state) {
      getBatchFromState(state, id).state = BATCH_STATES.ABORTED;
    });
    triggerUploaderBatchEvent(queue, id, UPLOADER_EVENTS.BATCH_ABORT);
  }
};

export { abortAll, abortItem, abortBatch };