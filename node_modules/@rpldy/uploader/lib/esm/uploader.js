import addLife, { createLifePack } from "@rpldy/life-events";
import { BATCH_STATES, invariant, logger, triggerCancellable, devFreeze, merge, clone } from "@rpldy/shared";
import getProcessor from "./processor";
import { UPLOADER_EVENTS } from "./consts";
import { getMandatoryOptions, deepProxyUnwrap } from "./utils";
var EVENT_NAMES = Object.values(UPLOADER_EVENTS);
var EXT_OUTSIDE_ENHANCER_TIME = "Uploady - uploader extensions can only be registered by enhancers",
    EXT_ALREADY_EXISTS = "Uploady - uploader extension by this name [%s] already exists";
var counter = 0;
export default (function (options) {
  counter += 1;
  var uploaderId = "uploader-".concat(counter);
  var enhancerTime = false;
  var pendingBatches = [],
      extensions = {};
  logger.debugLog("uploady.uploader: creating new instance (".concat(uploaderId, ")"), {
    options: options,
    counter: counter
  });
  var uploaderOptions = getMandatoryOptions(options);

  var update = function (updateOptions) {
    //TODO: updating concurrent and maxConcurrent means we need to update the processor - not supported yet!
    uploaderOptions = merge({}, uploaderOptions, updateOptions); //need deep merge for destination

    return uploader;
  };

  var add = function (files, addOptions) {
    var processOptions = merge({}, uploaderOptions, addOptions);
    var batch = processor.addNewBatch(files, uploader.id, processOptions);
    var resultP;

    if (batch.items.length) {
      resultP = processor.runCancellable(UPLOADER_EVENTS.BATCH_ADD, batch, processOptions).then(function (isCancelled) {
        if (!isCancelled) {
          logger.debugLog("uploady.uploader [".concat(uploader.id, "]: new items added - auto upload =\n                        ").concat(String(processOptions.autoUpload)), batch.items);

          if (processOptions.autoUpload) {
            processor.process(batch);
          } else {
            if (processOptions.clearPendingOnAdd) {
              clearPending();
            }

            pendingBatches.push({
              batch: batch,
              uploadOptions: processOptions
            });
          }
        } else {
          batch.state = BATCH_STATES.CANCELLED;
          triggerWithUnwrap(UPLOADER_EVENTS.BATCH_CANCEL, batch);
        }
      });
    } else {
      logger.debugLog("uploady.uploader: no items to add. batch ".concat(batch.id, " is empty. check fileFilter if this isn't intended"));
    }

    return resultP || Promise.resolve();
  };

  var clearPending = function () {
    pendingBatches.splice(0);
  };
  /**
   * Tells the uploader to process batches that weren't auto-uploaded
   */


  var getOptions = function () {
    return clone(uploaderOptions);
  };

  var registerExtension = function (name, methods) {
    invariant(enhancerTime, EXT_OUTSIDE_ENHANCER_TIME);
    invariant(!extensions[name], EXT_ALREADY_EXISTS, name);
    logger.debugLog("uploady.uploader: registering extension: ".concat(name.toString()), methods);
    extensions[name] = methods;
  };

  var _addLife = addLife({
    id: uploaderId,
    update: update,
    add: add,
    upload: function upload(uploadOptions) {
      pendingBatches.splice(0).forEach(function (_ref) {
        var batch = _ref.batch,
            batchOptions = _ref.uploadOptions;
        return processor.process(batch, merge({}, batchOptions, uploadOptions));
      });
    },
    abort: function abort(id) {
      processor.abort(id);
    },
    abortBatch: function abortBatch(id) {
      processor.abortBatch(id);
    },
    getOptions: getOptions,
    getPending: function getPending() {
      return pendingBatches.slice();
    },
    clearPending: clearPending,
    registerExtension: registerExtension,
    getExtension: function getExtension(name) {
      return extensions[name];
    }
  }, EVENT_NAMES, {
    canAddEvents: false,
    canRemoveEvents: false
  }),
      trigger = _addLife.trigger,
      uploader = _addLife.target;
  /**
   * ensures that data being exposed to client-land isnt a proxy, only pojos
   */


  var triggerWithUnwrap = function (name) {
    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    //delays unwrap to the very last time on trigger. Will only unwrap if there are listeners
    var lp = createLifePack(function () {
      return data.map(deepProxyUnwrap);
    });
    return trigger(name, lp);
  };

  var cancellable = triggerCancellable(triggerWithUnwrap);

  if (uploaderOptions.enhancer) {
    enhancerTime = true;
    var enhanced = uploaderOptions.enhancer(uploader, triggerWithUnwrap);
    enhancerTime = false; //graceful handling for enhancer forgetting to return uploader

    uploader = enhanced || uploader;
  }

  var processor = getProcessor(triggerWithUnwrap, cancellable, uploaderOptions, uploader.id);
  return devFreeze(uploader);
});