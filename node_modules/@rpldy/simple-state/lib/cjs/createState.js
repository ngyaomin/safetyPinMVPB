"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "isProxy", {
  enumerable: true,
  get: function get() {
    return _utils.isProxy;
  }
});
exports.unwrap = exports["default"] = void 0;

var _shared = require("@rpldy/shared");

var _consts = require("./consts");

var _utils = require("./utils");

var mergeWithSymbols = (0, _shared.getMerge)({
  withSymbols: true,
  predicate: function predicate(key) {
    return key !== _consts.PROXY_SYM && key !== _consts.STATE_SYM;
  }
});

var getIsUpdateable = function (proxy) {
  return (0, _shared.isProduction)() ? true : proxy[_consts.STATE_SYM].isUpdateable;
};

var setIsUpdateable = function (proxy, value) {
  if (!(0, _shared.isProduction)()) {
    proxy[_consts.STATE_SYM].isUpdateable = value;
  }
};

var deepProxy = function (obj, traps) {
  var proxy;

  if ((0, _utils.isProxiable)(obj)) {
    if (!(0, _utils.isProxy)(obj)) {
      obj[_consts.PROXY_SYM] = true;
      proxy = new Proxy(obj, traps);
    }

    Object.keys(obj).forEach(function (key) {
      obj[key] = deepProxy(obj[key], traps);
    });
  }

  return proxy || obj;
};

var unwrapProxy = function (proxy) {
  return (0, _utils.isProxy)(proxy) ? (0, _shared.clone)(proxy, mergeWithSymbols) : proxy;
};
/**
 * deep proxies an object so it is only updateable through an update callback.
 * outside an updater, it is impossible to make changes
 *
 * This a very (very) basic and naive replacement for Immer
 *
 * It only proxies simple objects (not maps or sets) and arrays
 * It doesnt create new references and doesnt copy over anything
 *
 * Original object is changed!
 *
 * DOESNT support updating state (wrapped seperately) that is set as a child of another state
 * @param obj
 * @returns {{state, update, unwrap}}
 */


exports.unwrap = unwrapProxy;

var _default = function _default(obj) {
  var traps = {
    set: function set(obj, key, value) {
      if (getIsUpdateable(proxy)) {
        obj[key] = deepProxy(value, traps);
      }

      return true;
    },
    get: function get(obj, key) {
      return key === _consts.PROXY_SYM ? unwrapProxy(obj) : obj[key];
    },
    defineProperty: function defineProperty() {
      throw new Error("Simple State doesnt support defining property");
    },
    setPrototypeOf: function setPrototypeOf() {
      throw new Error("Simple State doesnt support setting prototype");
    },
    deleteProperty: function deleteProperty(obj, key) {
      if (getIsUpdateable(proxy)) {
        delete obj[key];
      }

      return true;
    }
  };

  if (!(0, _shared.isProduction)() && !(0, _utils.isProxy)(obj)) {
    Object.defineProperty(obj, _consts.STATE_SYM, {
      value: {
        isUpdateable: false
      },
      configurable: true
    });
  }

  var proxy = !(0, _shared.isProduction)() ? deepProxy(obj, traps) : obj;
  return {
    state: proxy,
    update: function update(fn) {
      if (!(0, _shared.isProduction)() && getIsUpdateable(proxy)) {
        throw new Error("Can't call update on State already being updated!");
      }

      try {
        setIsUpdateable(proxy, true);
        fn(proxy);
      } finally {
        setIsUpdateable(proxy, false);
      }

      return proxy;
    },
    unwrap: function unwrap(entry) {
      return entry ? //simply clone the provided object (if its a proxy)
      unwrapProxy(entry) : //unwrap entire proxy state
      (0, _utils.isProxy)(proxy) ? unwrapProxy(proxy) : proxy;
    }
  };
};

exports["default"] = _default;